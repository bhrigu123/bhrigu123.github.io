<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code | Bhrigu Srivastava]]></title>
  <link href="http://bhrigu.me/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://bhrigu.me/"/>
  <updated>2017-11-07T00:31:42+05:30</updated>
  <id>http://bhrigu.me/</id>
  <author>
    <name><![CDATA[Bhrigu Srivastava]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LRU Cache - C++ Implementation]]></title>
    <link href="http://bhrigu.me/blog/2017/01/22/lru-cache-c-plus-plus-implementation/"/>
    <updated>2017-01-22T23:50:26+05:30</updated>
    <id>http://bhrigu.me/blog/2017/01/22/lru-cache-c-plus-plus-implementation</id>
    <content type="html"><![CDATA[<p>LRU, or <em>Least Recetly Used</em>, is one of the <a href="https://en.wikipedia.org/wiki/Page_replacement_algorithm">Page Replacement Algorithms</a>, in which the system manages a given amount of memory - by making decisions what pages to keep in memory, and which ones to remove when the memory is full.  <!-- more --></p>

<p>Let&rsquo;s say, the capacity of a given cache (memory) is <em>C</em>.</p>

<p>Our memory stores key, value pairs in it.</p>

<p>It should support the following operations:</p>

<ul>
<li><p><code>get(key)</code> -  Get the value of the given key if it exists in the memory (else, let&rsquo;s say -1)</p></li>
<li><p><code>put(key, value)</code> - Set, or insert the value if not present. If our cache reaches its capacity, we should remove the item which was least recently used.</p></li>
</ul>


<p>Another constraint to the given problem is:<br>
Both the operations must be done in constant <a href="https://en.wikipedia.org/wiki/Time_complexity">Time Complexity</a>, ie in <em>O(1)</em>.</p>

<p>Now, we need to think of some of the data structures, which would allow us to perform the above operations in <em>O(1)</em>.</p>

<h3>Choice of data structures</h3>

<ul>
<li><p><strong>Queue</strong> - We should maintain a Queue (double ended queue), in which the most recently used pages (items) are in the front, and the least recently used pages are in the rear. This would allow to remove the least recently used item in <em>O(1)</em> time.</p></li>
<li><p><strong>Doubly Linked List</strong> - We should implement our Queue using a doubly linked list (instead of arrays), which would allow us to apply <em>shifting</em> operations in <em>O(1)</em> time. (like, when we need to shift a page to the front of the queue)</p></li>
<li><p><strong>HashMap</strong> - We should hash the key values to the location where the page is stored. This would allow <code>get</code> operation in <em>O(1)</em> time.</p></li>
</ul>


<h3>Design and Implementation</h3>

<p>Now that we know which what all data structures to use, let&rsquo;s look at the implementation.</p>

<p>Whenever a user <code>gets</code> a page, we return its value, and also move that page to the front of our Queue.</p>

<p>Whenever a user <code>sets</code> a page, if the page is already present, we update its value and move that page to the front of our Queue, <br>
else we add a new page to our cache in the front of the Queue.<br>
But if our cache has reached its capacity, we remove the least recently used page (ie the rear item in our Queue) from our memory.</p>

<ol>
    <li>
        <code>class Node</code>
        <ul>
            <li>
                Data members:
                <ol>
                    <li>key</li>
                    <li>value</li>
                    <li>next node address</li>
                    <li>previous node address</li>
                </ol>
            </li>
        </ul>
    </li><br>

    <li>
        <code>class DoublyLinkedList</code>
        <ul>
            <li>
                Data members:
                <ol>
                    <li>front node address</li>
                    <li>rear node address</li>
                </ol>
            </li>

            <li>
                Member functions:
                <ol>
                    <li>move_page_to_head(..)</li>
                    <li>remove_rear_page()</li>
                    <li>get_rear_page()</li>
                    <li>add_page_to_head(..)</li>
                </ol>
            </li>

        </ul>
    </li><br>

    <li>
        <code>class LRU</code>
        <ul>
            <li>
                Data members:
                <ol>
                    <li>capacity</li>
                    <li>current size</li>
                    <li>a DoublyLinkedList object</li>
                    <li>Hashmap</li>
                </ol>
            </li>

            <li>
                Member functions:
                <ol>
                    <li>get(key)</li>
                    <li>put(key, value)</li>
                </ol>
            </li>

        </ul>
    </li>

</ol>


<p>Let&rsquo;s make the 3 classes.</p>

<h3>Code</h3>

<p><figure class='code'><figcaption><span>LRU Cache cpp (LRUCache.cpp)</span> <a href='/downloads/code/LRUCache.cpp'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;map&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
</span><span class='line'>	<span class="k">public</span><span class="o">:</span>
</span><span class='line'>	<span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>	<span class="n">Node</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>	<span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span><span class="o">:</span> <span class="n">key</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">prev</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">DoublyLinkedList</span> <span class="p">{</span>
</span><span class='line'>	<span class="n">Node</span> <span class="o">*</span><span class="n">front</span><span class="p">,</span> <span class="o">*</span><span class="n">rear</span><span class="p">;</span>
</span><span class='line'>	
</span><span class='line'>	<span class="kt">bool</span> <span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>		<span class="k">return</span> <span class="n">rear</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="k">public</span><span class="o">:</span>
</span><span class='line'>	<span class="n">DoublyLinkedList</span><span class="p">()</span><span class="o">:</span> <span class="n">front</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">rear</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>	
</span><span class='line'>	<span class="n">Node</span><span class="o">*</span> <span class="n">add_page_to_head</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>		<span class="n">Node</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">front</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>			<span class="n">front</span> <span class="o">=</span> <span class="n">rear</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="k">else</span> <span class="p">{</span>
</span><span class='line'>			<span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>
</span><span class='line'>			<span class="n">front</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span><span class='line'>			<span class="n">front</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="k">return</span> <span class="n">page</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="kt">void</span> <span class="n">move_page_to_head</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>		<span class="k">if</span><span class="p">(</span><span class="n">page</span><span class="o">==</span><span class="n">front</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>			<span class="k">return</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="k">if</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>			<span class="n">rear</span> <span class="o">=</span> <span class="n">rear</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'>			<span class="n">rear</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="k">else</span> <span class="p">{</span>
</span><span class='line'>			<span class="n">page</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>			<span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>		<span class="n">page</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>
</span><span class='line'>		<span class="n">page</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>		<span class="n">front</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span><span class='line'>		<span class="n">front</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>	<span class="kt">void</span> <span class="n">remove_rear_page</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>			<span class="k">return</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="k">if</span><span class="p">(</span><span class="n">front</span> <span class="o">==</span> <span class="n">rear</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>			<span class="k">delete</span> <span class="n">rear</span><span class="p">;</span>
</span><span class='line'>			<span class="n">front</span> <span class="o">=</span> <span class="n">rear</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>		<span class="k">else</span> <span class="p">{</span>
</span><span class='line'>			<span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">rear</span><span class="p">;</span>
</span><span class='line'>			<span class="n">rear</span> <span class="o">=</span> <span class="n">rear</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'>			<span class="n">rear</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>			<span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>		<span class="p">}</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	<span class="n">Node</span><span class="o">*</span> <span class="n">get_rear_page</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>		<span class="k">return</span> <span class="n">rear</span><span class="p">;</span>
</span><span class='line'>	<span class="p">}</span>
</span><span class='line'>	
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">{</span>
</span><span class='line'>	<span class="kt">int</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>	<span class="n">DoublyLinkedList</span> <span class="o">*</span><span class="n">pageList</span><span class="p">;</span>
</span><span class='line'>	<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Node</span><span class="o">*&gt;</span> <span class="n">pageMap</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>	<span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">LRUCache</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    	<span class="k">this</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
</span><span class='line'>    	<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="n">pageList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DoublyLinkedList</span><span class="p">();</span>
</span><span class='line'>        <span class="n">pageMap</span> <span class="o">=</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Node</span><span class="o">*&gt;</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">pageMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">==</span><span class="n">pageMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">pageMap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// move the page to front</span>
</span><span class='line'>        <span class="n">pageList</span><span class="o">-&gt;</span><span class="n">move_page_to_head</span><span class="p">(</span><span class="n">pageMap</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="n">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    	<span class="k">if</span><span class="p">(</span><span class="n">pageMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">!=</span><span class="n">pageMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    		<span class="c1">// if key already present, update value and move page to head</span>
</span><span class='line'>    		<span class="n">pageMap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>    		<span class="n">pageList</span><span class="o">-&gt;</span><span class="n">move_page_to_head</span><span class="p">(</span><span class="n">pageMap</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
</span><span class='line'>    		<span class="k">return</span><span class="p">;</span>
</span><span class='line'>    	<span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        	<span class="c1">// remove rear page</span>
</span><span class='line'>        	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">pageList</span><span class="o">-&gt;</span><span class="n">get_rear_page</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
</span><span class='line'>        	<span class="n">pageMap</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span><span class='line'>        	<span class="n">pageList</span><span class="o">-&gt;</span><span class="n">remove_rear_page</span><span class="p">();</span>
</span><span class='line'>        	<span class="n">size</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// add new page to head to Queue</span>
</span><span class='line'>        <span class="n">Node</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pageList</span><span class="o">-&gt;</span><span class="n">add_page_to_head</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span><span class='line'>        <span class="n">size</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="n">pageMap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">~</span><span class="n">LRUCache</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    	<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Node</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">i1</span><span class="p">;</span>
</span><span class='line'>    	<span class="k">for</span><span class="p">(</span><span class="n">i1</span><span class="o">=</span><span class="n">pageMap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">i1</span><span class="o">!=</span><span class="n">pageMap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">i1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    		<span class="k">delete</span> <span class="n">i1</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>    	<span class="p">}</span>
</span><span class='line'>    	<span class="k">delete</span> <span class="n">pageList</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></p>

<h3>Running the code</h3>

<p>Save the above code in a file, say of name <code>LRUCache.cpp</code>.</p>

<p>In the same directory create another <code>.cpp</code> file in which we will use get() and put() functions of our LRU. Paste the code below, compile &amp; run it:</p>

<pre><code class="cpp RunLRUCache.cpp">#include &lt;iostream&gt;
#include "LRUCache.cpp"
using namespace std;

int main() {
    LRUCache cache(2);  // cache capacity 2
    cache.put(2,2);
    cout &lt;&lt; cache.get(2) &lt;&lt; endl;
    cout &lt;&lt; cache.get(1) &lt;&lt; endl;
    cache.put(1,1);
    cache.put(1,5);
    cout &lt;&lt; cache.get(1) &lt;&lt; endl;
    cout &lt;&lt; cache.get(2) &lt;&lt; endl;
    cache.put(8,8);
    cout &lt;&lt; cache.get(1) &lt;&lt; endl;
    cout &lt;&lt; cache.get(8) &lt;&lt; endl;

}
</code></pre>

<p><strong><u>Output:</u></strong></p>

<pre><code class="sh output">2
-1
5
2
-1
8
</code></pre>

<p>The output comes out to be correct (you can check by creating a cache of size 2, and executing the given <code>get</code> and <code>put</code> functions in the above order.)</p>

<p>That is all for LRU Cache implementation - ie, the &ldquo;Least Recently Used Page replacement algorithm&rdquo;.</p>

<p><code>Notes:</code></p>

<blockquote><p>Use <a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/">unordered_map</a> instead of ordered maps as used above (ie just <code>map</code> was used above) to make it <strong><em>really</em></strong> O(1). To read difference: <a href="http://www.geeksforgeeks.org/unordered_map-in-stl-and-its-applications/">unordered_map and map</a>.</p>

<p>The LRU Cache problem is available on Leetcode at: <a href="https://leetcode.com/problems/lru-cache/">LRU Cache</a>
if you want to check it out.</p></blockquote>

<p>Any feedback, doubts or questions, please leave in the comments.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Huffman Coding - Python Implementation]]></title>
    <link href="http://bhrigu.me/blog/2017/01/17/huffman-coding-python-implementation/"/>
    <updated>2017-01-17T23:47:55+05:30</updated>
    <id>http://bhrigu.me/blog/2017/01/17/huffman-coding-python-implementation</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman Coding</a> is one of the lossless data compression techniques. It assigns variable-length codes to the input characters, based on the frequencies of their occurence. The most frequent character is given the smallest length code. <br> <!-- more --></p>

<center>
    <img class="[erimg]" src="/images/huffman/huffman.png" title="HuffmanCoding" >
</center>


<p><br></p>

<p>I thought of implementing the data compression program. The key things in the implementation were: <br></p>

<ul>
<li><p>Building frequency dictionary</p></li>
<li><p>Select 2 minimum frequency symbols and merge them repeatedly: Used Min Heap</p></li>
<li><p>Build a tree of the above process: Created a HeapNode class and used objects to maintain tree structure</p></li>
<li><p>Assign code to characters: Recursively traversed the tree and assigned the corresponding codes</p></li>
<li><p>Encode the input text. Added padding to the encoded text, if it&rsquo;s not of a length of multiple of 8. Stored this padding information, in 8 bits, in the beginning of the resultant code.</p></li>
<li><p>Write the result to an output binary file, which will be our compressed file.</p></li>
</ul>


<h3 style="margin: 0;
    font-weight: 600;
    color: #888;">
    End result</h3>


<p>After running on a several sample text files, Compression Ratio on an average was achieved to be 2.1 : 1.</p>

<p>So it&rsquo;s like you have your very own text file compression program.</p>

<p>I implemented both the <em>compression</em> and <em>decompression</em> functions. Decompressing the compressed file brought back the original state of the file, without any data loss.</p>

<p>Before you look at the code from beginning, first check out the outline of the 2 functions <strong>compress</strong> (line 101) and <strong>decompress</strong> (line 157) , and then look at details of the other functions called from them.</p>

<table class="table">
    <tr class="center">
        <th>Compression <small style="font-weight: normal;"> (line 101)</small></th>
        <th>Decompression <small style="font-weight: normal;"> (line 157)</small></th>
    </tr>
    <tr>
        <td>
            <ol>
                <li>Make frequency dictionary</li>
                <li>Make heap</li>
                <li>Merge Nodes and build tree</li>
                <li>Make codes</li>
                <li>Encode Text</li>
                <li>Pad encodded text</li>
                <li>Make byte array</li>
                <li>Output the byte array to binary file</li>
            </ol>
        </td>
        <td>
            <ol>
                <li>Read binary file</li>
                <li>Remove padding</li>
                <li>Decode text</li>
                <li>Output decoded text to txt file</li>
            </ol>
        </td>
    </tr>
</table>


<p>The class <code>HuffmanCoding</code> takes complete path of the text file to be compressed as parameter. (as its data members store data specific to the input file).</p>

<p>The <em>compress()</em> function returns the path of the output compressed file.</p>

<p>The function <em>decompress()</em> requires path of the file to be decompressed. (and <em>decompress()</em> is to be called from the same object created for <em>compression</em>, so as to get code mapping from its data members)</p>

<p><div><script src='https://gist.github.com/a0e50b1b468cff905346b451ab3a2c39.js?file=HuffmanCoding.py'></script>
<noscript><pre><code>import heapq
import os

class HeapNode:
	def __init__(self, char, freq):
		self.char = char
		self.freq = freq
		self.left = None
		self.right = None

	def __cmp__(self, other):
		if(other == None):
			return -1
		if(not isinstance(other, HeapNode)):
			return -1
		return self.freq &gt; other.freq


class HuffmanCoding:
	def __init__(self, path):
		self.path = path
		self.heap = []
		self.codes = {}
		self.reverse_mapping = {}

	# functions for compression:

	def make_frequency_dict(self, text):
		frequency = {}
		for character in text:
			if not character in frequency:
				frequency[character] = 0
			frequency[character] += 1
		return frequency

	def make_heap(self, frequency):
		for key in frequency:
			node = HeapNode(key, frequency[key])
			heapq.heappush(self.heap, node)

	def merge_nodes(self):
		while(len(self.heap)&gt;1):
			node1 = heapq.heappop(self.heap)
			node2 = heapq.heappop(self.heap)

			merged = HeapNode(None, node1.freq + node2.freq)
			merged.left = node1
			merged.right = node2

			heapq.heappush(self.heap, merged)


	def make_codes_helper(self, root, current_code):
		if(root == None):
			return

		if(root.char != None):
			self.codes[root.char] = current_code
			self.reverse_mapping[current_code] = root.char
			return

		self.make_codes_helper(root.left, current_code + &quot;0&quot;)
		self.make_codes_helper(root.right, current_code + &quot;1&quot;)


	def make_codes(self):
		root = heapq.heappop(self.heap)
		current_code = &quot;&quot;
		self.make_codes_helper(root, current_code)


	def get_encoded_text(self, text):
		encoded_text = &quot;&quot;
		for character in text:
			encoded_text += self.codes[character]
		return encoded_text


	def pad_encoded_text(self, encoded_text):
		extra_padding = 8 - len(encoded_text) % 8
		for i in range(extra_padding):
			encoded_text += &quot;0&quot;

		padded_info = &quot;{0:08b}&quot;.format(extra_padding)
		encoded_text = padded_info + encoded_text
		return encoded_text


	def get_byte_array(self, padded_encoded_text):
		if(len(padded_encoded_text) % 8 != 0):
			print(&quot;Encoded text not padded properly&quot;)
			exit(0)

		b = bytearray()
		for i in range(0, len(padded_encoded_text), 8):
			byte = padded_encoded_text[i:i+8]
			b.append(int(byte, 2))
		return b


	def compress(self):
		filename, file_extension = os.path.splitext(self.path)
		output_path = filename + &quot;.bin&quot;

		with open(self.path, &#39;r+&#39;) as file, open(output_path, &#39;wb&#39;) as output:
			text = file.read()
			text = text.rstrip()

			frequency = self.make_frequency_dict(text)
			self.make_heap(frequency)
			self.merge_nodes()
			self.make_codes()

			encoded_text = self.get_encoded_text(text)
			padded_encoded_text = self.pad_encoded_text(encoded_text)

			b = self.get_byte_array(padded_encoded_text)
			output.write(bytes(b))

		print(&quot;Compressed&quot;)
		return output_path


	&quot;&quot;&quot; functions for decompression: &quot;&quot;&quot;

	def remove_padding(self, padded_encoded_text):
		padded_info = padded_encoded_text[:8]
		extra_padding = int(padded_info, 2)

		padded_encoded_text = padded_encoded_text[8:] 
		encoded_text = padded_encoded_text[:-1*extra_padding]

		return encoded_text

	def decode_text(self, encoded_text):
		current_code = &quot;&quot;
		decoded_text = &quot;&quot;

		for bit in encoded_text:
			current_code += bit
			if(current_code in self.reverse_mapping):
				character = self.reverse_mapping[current_code]
				decoded_text += character
				current_code = &quot;&quot;

		return decoded_text


	def decompress(self, input_path):
		filename, file_extension = os.path.splitext(self.path)
		output_path = filename + &quot;_decompressed&quot; + &quot;.txt&quot;

		with open(input_path, &#39;rb&#39;) as file, open(output_path, &#39;w&#39;) as output:
			bit_string = &quot;&quot;

			byte = file.read(1)
			while(byte != &quot;&quot;):
				byte = ord(byte)
				bits = bin(byte)[2:].rjust(8, &#39;0&#39;)
				bit_string += bits
				byte = file.read(1)

			encoded_text = self.remove_padding(bit_string)

			decompressed_text = self.decode_text(encoded_text)
			
			output.write(decompressed_text)

		print(&quot;Decompressed&quot;)
		return output_path</code></pre></noscript></div>
</p>

<h3 style="margin: 0;
    font-weight: 600;
    color: #888;">
    Running the program:</h3>


<p>Save the above code.</p>

<p>Create a sample text file. Or download a sample file from <a href="https://raw.githubusercontent.com/bhrigu123/huffman-coding/master/sample.txt">sample.txt</a> (right click, save as)</p>

<p>Save the code below, in the same directory as the above code, and Run this python code (edit the <code>path</code> variable below before running. initialize it to text file path)</p>

<pre><code class="python UseHuffman.py">from huffman import HuffmanCoding

#input file path
path = "/home/ubuntu/Downloads/sample.txt"

h = HuffmanCoding(path)

output_path = h.compress()
h.decompress(output_path)
</code></pre>

<p>The compressed <code>.bin</code> file and the decompressed file are both saved in the same directory as of the input file.</p>

<h3 style="margin: 0;
    font-weight: 600;
    color: #888;">
    Result</h3>


<p>On running on the above linked sample text file:</p>

<table class="table">
    <tr>
        <td><b>Initial Size:</b></td>
        <td>715.3 kB</td>
    </tr>
    <tr>
        <td><b>Compressed file Size:</b></td>
        <td>394.0 kB</td>
    </tr>
</table>


<p>Plus, the decompressed file comes out to be exactly the same as the original file, without any data loss.</p>

<p>And that is all for Huffman Coding implementation, with compression and decompression. This was fun to code.</p>

<blockquote><p>The above program requires the decompression function to be run using the same object that created the compression file (because the code mapping is stored in its data members). We can also make the compression and decompression function run independently, if somehow, during compression we store the mapping info also in the compressed file (in the beginning). Then, during decompression, we will first read the mapping info from the file, then use that mapping info to decompress the rest file.</p></blockquote>

<p><button type="button" class="btn btn-default">
    <a href="https://github.com/bhrigu123/huffman-coding" target="_blank">
    View on GitHub</a>
</button></p>
]]></content>
  </entry>
  
</feed>
